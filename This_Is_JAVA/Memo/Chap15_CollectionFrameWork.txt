1-1 CollectionFrameWork 개요
○컬렉션
	- 요소(객체)를 수집하여 저장하는 것
○배열의 문제점
	- JAVA에서  컬렉션을 제공해주는 이유임!!
	=> 저장할 수 있는 객체수가 배열을 생성할 때 결정된다. (배열의 길이가 정해짐)
		-> 불특정 다수의 객체를 저장하기에는 문제가 있다.
	=> 객체를 삭제 했을 때 해당 인덱스가 비게 된다. 
		-> 낱알 빠진 옥수수같이... 비유 찰지는구만
		-> 객체를 저장하려면 어디가 비어있는 지 확인해야한다.
		-> 그 검사하는 코드를 먼저 사용해야하므로 비효율적임.
	=> 컬렉션은 이 두가지 문제를 해결!

○컬렉션 프레임워크
	- 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 제공되는 컬렉션 라이브러리
	- 프레임워크 : 인터페이스와 클래스의 모음이라고 생각하면 됨!!
	- java.util 패키지에 포함된다. 
	- 인터페이스를 통해서 정형화된 방법으로 다양한 클렉션 클래스를 이용! 
		=> 컬렉션을 사용하는 방법이 통일되어있어서 매우 쉽게 사용가능하다!

※ 컬렉션 프레임워크의 주요 인터페이스
	-List
	=> 배열과 유사하게 인덱스로 관리
	=> 인덱스에 객체를 저장
		- 구현 클래스 : ArrayList, Vector, LinkedList
	=특징
		- 순서를 유지하고 저장 (인덱스)
		- 중복 저장이 가능하다. 
	
	-Set
	=> 집합과 유사하다.
	=> 구술 주머니와 비슷. 객체를 주머니에 저장 한다고 생각하기
		-구현 클래스 : HashSet, TreeSet
	=특징
		- 순서를 유지하지 않고 저장 ! 주머니에 저장~!!
		- 중복 저장 불가! (주머니에 똑같은거 못들어감)	
			=> 동일한 객체를 넣으면 오류남

	-Map
	=> 키와 값의 쌍으로 객체를 관리
	=> List와 유사하지만, List는 인덱스로 저장하는 것에 반해
	Key로 저장을 한다. 각 Key마다 객체가 저장이되고, 쌍으로 관리된다. 
		- 구현 클래스 : HashMap, HashTable, TreeMap, Properties
	=특징
		- 키와 값의 쌍으로 저장이 된다. 
		- 키는 중복 저장이 안된다. (List의 인덱스가 중복이 말이안되는것처럼)
		- 키가 다르다면 값은 중복으로 저장 가능하다.


1-2 List 컬렉션
List인터페이스를 구현한 컬렉션
○특징
	- 인덱스로 관리
	- 중복해서 객체 저장 가능
	- 실질적으로는 해당 인덱스에 객체의 주소값이 저장되는것임!
○구현 클래스
	-ArrayList
	-Vector
	-LinkedList
○주요 메소드
- 객체추가
	=boolean add(E element)
	-> 주어진 객체를 List의 맨 끝에 추가
	-> return 값이 boolean. 성공적으로 추가되면 true가 리턴됨

	=void add(int index, E element)
	-> 주어진 인덱스에 객체를 추가
	-> 객체를 수정하는 것이아니라, 새로운 공간이 생기고 기존 인덱스는 뒤로 밀림.
	-> 중간에 삽입을 하는것이다.!
	
	=set (int index, E element)
	-> 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿈! 이것은 수정!
 
-객체검색
	=boolean contains(Object o)
	-> 주어진 객체가 저장되어 있는지 여부를 리턴함

	=E get (int index)
	-> 가장 많이 사용함
	-> 주어진 인덱스에 저장된 객체를 리턴한다. 
	-> 즉, 인덱스에 있는 객체를 불러올 때 사용!
	
	=boolean isEmpty()
	-> 컬렉션 자체가 비어있는지 아닌지를 살핀다. 
	-> 비어있으면 true, 비어있지 않으면 false

	=int size()
	-> 저장되어있는 전체 객체수!! 를 리턴한다. (length라고 생각하면댐)
	-> 객체가 중복되어도, 인덱스에 저장된것을 센다.

- 객체 삭제
	= void clear()
	-> 컬렉션 안에 저장된 모든 객체를 삭제함

	= E remove (int index)
	-> 해당 인덱스에 저장된 객체를 삭제하고, 삭제된 객체가 리턴된다.
	-> 인덱스를 알고있으면 이걸 사용

	= boolean remove(Object O)
	-> 주어진 객체를 삭제한다. 
	-> 객체를 알고있으면 이걸 사용
	-> 중복된 객체라면 그 해당 객체를 담은 인덱스가 모두 삭제된다. 
	

○ArrayList 클래스
List <E> list = new ArrayList <E> ();

- 저장용량 (capacity)
	-초기값 : 10
	-초기 용량 지정가능하다. 생성자의 매개값에 넣으면댐
	-저장용량을 초과한 객체들이 들어오면 자동적으로 늘어난다. 이것이 배열과 차이!

- 객체 제거
	- 객체가 제거되면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다
	

- 고정된 객체들로 구성된 List 생성
=>객체들이 고정되어있다면 add를 사용하면 도리어 불편함
List<T> list = Arrays.asList(T....a);
	=> Arrays.asList()를 사용하는것이 간편

List<String> list1 = Arrays.asList("홍길동", "신용권", "김자바");
for(String name : list1) {
	syso (name);
}

○Vector 클래스
List <E> list = new Vector <E> ();
- 특징
	= Vector는 스레드 동기화 (synchronization) 되어있기 때문에
	복수의 스레드가 동시에 vector에 접근해서 객체를 추가, 삭제하더라도
	스레드에 안전(thread safe) 하다. 
	=> ArrayList와 사용이 똑같지만, 멀티스레드환경에서 사용한다.
	=> ArrayList는 싱글스레드에서 사용된다. 

※ArrayList
	public boolean add {...}

Vector
	public synchronized boolean add {...}

즉, Vector는 메소드가 동기화되어있으므로 멀티스레스환경에서 안전하다!
즉, 하나의 스레드가 실행하고있으면 다른 스레드들이 사용하지 못한다. 
두 스레드가 동시에 어떤 객체를 Vector에 저장하려고할때,
어떤 스레드부터 저장할것인가? 에대한 고민을 해결시켜줌. 

그러나 싱글스레드에서는 ArrayList가 좀더 빠르게 작업을 처리하므로,
싱글스레드에서는 ArrayList를 사용한다. 








